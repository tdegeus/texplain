#!/usr/bin/env python

import sys,os,argparse,re
from shutil import copyfile

# ==============================================================================

def printversion():
  print(r'''
Version 1.2

  - Included "\lstinputlisting{...}" (including "--flatten-scripts" option).

Version 1.1

  - Improved robustness.
  - Reprogrammed to enhance durability.

Version 1.0
  ''')
  sys.exit(0)

# ==============================================================================

def printhelp():
  print('''
NAME

  texplain - create a clean output directory with only included files/citations

USAGE

  $ texplain INPUT.TEX OUTPUT-PATH

DESCRIPTION

  Copy the TeX-file and only those figure-files and references that are included
  in it to a separate folder. This is particularly useful to create a clean
  version to submit to a journal.

OPTIONS

  -h, --help
    Print help

  --version
    Print version

  --copy-bbl=Y|N
    Copy existing bbl-files.

  --flatten-figures=Y|N
    If set 'Y' the figures are copied to the same folder as the main TeX-file.
    The file-names are modified:

      example/path/to/figure -> example_path_to_figure

  --flatten-scripts=Y|N
    If set 'Y' the scripts (in "\lstinputlisting{...}") are copied to the same
    folder as the main TeX-files (see "--flatten-figures")

RELEASE

  Version 1.1, April 2016

COPYRIGHT

  T.W.J. de Geus
  tom@geus.me
  www.geus.me

FEATURE REQUEST

  * Interpret "include", such that all dependencies are copied
  ''')

  sys.exit(0)

# ==============================================================================

# define options for argument parser
opts = [\
  ((     'input'            ),dict(nargs=1,type=str,metavar='INPUT.TEX'               )),
  ((     'output'           ),dict(nargs=1,type=str,metavar='OUTPUT-PATH'             )),
  ((     '--flatten-figures'),dict(nargs=1,type=str,metavar='Y|N'        ,default='Y' )),
  ((     '--flatten-scripts'),dict(nargs=1,type=str,metavar='Y|N'        ,default='Y' )),
  ((     '--copy-bbl'       ),dict(nargs=1,type=str,metavar='Y|N'        ,default='Y' )),
  (('-h','--help'           ),dict(action='store_true'                                )),
  ((     '--version'        ),dict(action='store_true'                                )),
]

# parse command-line arguments
# - catch help
if len(sys.argv)>1:
  if sys.argv[1] in ['-h','--help','-H']: printhelp()
  if sys.argv[1] in [     '--version'  ]: printversion()
# - create parser
parser = argparse.ArgumentParser(add_help=False)
for (arg,opt) in opts:
  if type(arg)==tuple: parser.add_argument(*arg,**opt)
  else               : parser.add_argument( arg,**opt)
# - execute parser / convert to "<dict>"
args = vars(parser.parse_args())
# - print help and exit
if args['help'   ]: printhelp()
if args['version']: printversion()

# convert from list
for key in ['input','output','flatten_figures','flatten_scripts','copy_bbl']:
  args[key] = args[key][0]

# convert to usable format
for key in ['flatten_figures','flatten_scripts','copy_bbl']:
  if   args[key].lower() in ['y','yes','true' ]: args[key] = True
  elif args[key].lower() in ['n','no' ,'false']: args[key] = False
  else: print('Unknown argument "--%s", use "Y" or "N"'%key.replace('_','-')); sys.exit(1)

# create output-directory
if not os.path.isdir(args['output']):
  os.mkdir(args['output'])

# ==============================================================================
# support functions
# ==============================================================================

# extract include commands and their file-names from TeX
# ------------------------------------------------------

def tex2incl(tex,cmd=r'\includegraphics'):

  # mimic the LaTeX behavior where an extension is automatically added to a
  # file-name without any extension
  def filename(name):
    if   os.path.isfile(name       ): return name
    elif os.path.isfile(name+'.pdf'): return name+'.pdf'
    elif os.path.isfile(name+'.png'): return name+'.png'
    elif os.path.isfile(name+'.jpg'): return name+'.jpg'
    elif os.path.isfile(name+'.tex'): return name+'.tex'
    print('Cannot find {0}').format(name)

  # read files in the include-commands
  include = [i.split('{')[1].split('}')[0] for i in tex.split(cmd)[1:]]
  files   = [filename(i) for i in include]

  # reduce to unique lists
  unique_include = []
  unique_files   = []

  for i,(inc,fil) in enumerate(zip(include,files)):
    if inc not in include[:i] and fil not in files[:i]:
      unique_include.append(inc)
      unique_files  .append(fil)

  # return ( include-command , file-names   )
  return   ( unique_include  , unique_files )

# flatten file-names and corresponding commands
# ---------------------------------------------

def flatten(include,files,tex,cmd=r'\includegraphics'):

  # flatten file-names
  new_files = [i.replace('/','_') for i in files]

  # check uniqueness
  for ifig,i in enumerate(files):
    if '/' in i:
      n = i.replace('/','_')
      j = 1
      while True:

        if ifig>0:
          if not os.path.isfile(n) and n not in new_files[:ifig]: break
        else:
          if not os.path.isfile(n): break

        name,ext = os.path.splitext(n)
        n        = name+'_{0:d}'.format(j)+ext
        j       += 1

      new_files[ifig] = n

  # convert file-names to commands as they were
  new_include = [fil.split(inc.split('/')[-1])[0]+inc.split('/')[-1] for inc,fil in zip(include,new_files)]

  # modify names in TeX
  for f,n in zip(include,new_include):
    tex = re.sub(r'(%s.*\{)('%cmd+f+r')(\}.*)',r'\1'+n+r'\3',tex)

  return new_files,new_include,tex

# extract citation-names
# ----------------------

def tex2cite(tex):

  # extract keys from "cite"
  def extract(string):
    try   : return list(re.split('([pt])?(\[.*\]\[.*\])?(\{[a-zA-Z0-9\,\-\ ]*\})',string)[3][1:-1].split(','))
    except: print('Error in interpreting\n {0} ...').format(string[:100])

  # read all keys in "cite", "citet", "citep" commands
  cite = [extract(i) for i in tex.split(r'\cite')[1:]]
  cite = list(set([item for sublist in cite for item in sublist]))
  cite = [i.replace(' ','') for i in cite]

  return cite

# copy (and create path)
# ----------------------

def cp(orig,dest):

  path = os.path.dirname(dest)

  if not os.path.isdir(path):
    os.makedirs(path)

  copyfile(orig,dest)

# ==============================================================================
# read information
# ==============================================================================

# read TeX-file, extract citations
tex   = open(args['input'],'r').read()
cite  = tex2cite(tex)

# check for unsupported features
if re.match(r'\input\{.*\}',tex) or re.match(r'\include\{.*\}',tex):
  print(r'TeX-files with \input{...} or \include{...} not yet supported')
  sys.exit(1)

# ==============================================================================
# copy figures/scripts
# ==============================================================================

for cmd,opt in zip([r'\includegraphics',r'\lstinputlisting'],['flatten_figures','flatten_scripts']):

  # extract include-commands and file-names
  (include,files) = tex2incl(tex,cmd=cmd)

  # set default: retain file-names
  new_files = [file for file in files]

  # optional: flatten file-names
  if args[opt]:
    new_files,new_include,tex = flatten(include,files,tex,cmd=cmd)

  # copy files
  for f,n in zip(files,new_files):
    cp(f,os.path.join(args['output'],n))

# ==============================================================================
# copy bibliography
# ==============================================================================

# read file-name
BIB = tex.split(r'\bibliography{')[1].split('}')[0]+'.bib'

# extract citations
bib = filter(None,open(BIB,'r').read().split('@'))[1:]
bib = [i for i in bib if re.split(r'(.*\{)(.*)(,\n.*)',i)[2] in cite]
bib = '\n@'+'\n@'.join(bib)

# write bibliography: only include citations
open(os.path.join(args['output'],BIB),'w').write(bib)

# ==============================================================================
# write TeX
# ==============================================================================

open(os.path.join(args['output'],args['input']),'w').write(tex)

# ==============================================================================
# copy: style / class / bst
# ==============================================================================

path  = os.path.dirname(args['input'])
path  = '.' if len(path)==0 else path
files = os.listdir(path)

# set extension to copy
ext = ['.sty','.cls','.bst']
if args['copy_bbl']: ext.append('.bbl')

# find auxiliary files
aux = []
for e in ext:
  aux += [i for i in files if re.match('.*\%s'%e,i)]

# copy files
for file in aux:
  cp(file,os.path.join(args['output'],file))

# copy figures referenced in style-files
files = []
for file in aux:
  files += tex2incl(open(file,'r').read())[1]
for file in files:
  cp(file,os.path.join(args['output'],file))
